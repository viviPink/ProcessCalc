using System;
using System.Collections.Concurrent; // Для потокобезопасной коллекции 
using System.Collections.Generic;    
using System.Threading;              
namespace th_pool
{
    
     // Класс ThreadPool представляет пул потоков для параллельного выполнения задач
    public class ThreadPool
    {
        // Список рабочих потоков
        private readonly List<Thread> workers;

         // workers хранит все созданные потоки, которые выполняют задачи из очереди

        // Очередь задач
        private readonly BlockingCollection<Action> tasks;

         // tasks — это потокобезопасная коллекция, которая хранит задачи для выполнения
         // Она используется для передачи задач от основного потока к рабочим потокам
         // BlockingCollection автоматически блокирует потоки, если очередь пуста, пока не появится новая задача
        // Флаг для остановки работы пула
         bool stop;

        /*
         * Зачем нужен флаг stop?
         * - stop указывает, следует ли остановить работу пула потоков.
         * - Когда stop = true, потоки завершают свою работу после обработки всех задач в очереди.
         */

        // Конструктор: создает пул из заданного количества потоков
        public ThreadPool(int numThreads)
        {
            workers = new List<Thread>();
            tasks = new BlockingCollection<Action>();
            stop = false;

            /*
             * Почему используется BlockingCollection<Action>?
             * - Action — это делегат, представляющий метод без параметров и без возвращаемого значения.
             * - BlockingCollection обеспечивает потокобезопасность при добавлении и извлечении задач.
             */

            // Создаем заданное количество рабочих потоков
            for (int i = 0; i < numThreads; i++)
            {
                var worker = new Thread(() =>
                {
                    
                     
                     // Каждый поток выполняет бесконечный цикл, пока не будет установлен флаг stop
                     // В цикле поток берет задачу из очереди tasks и выполняет ее
                    while (!stop || tasks.Count > 0)
                    {
                       
                            // Берем задачу из очереди
                            var task = tasks.Take();

                          
                             // Take() извлекает задачу из очереди. Если очередь пуста, поток блокируется до появления новой задачи
                             // Это позволяет эффективно распределять задачи между потоками
                            task(); // Выполняет задачу
                       
                    }
                });

                workers.Add(worker); // Добавляем поток в список workers
                worker.Start();      // Запускаем поток
            }
        }

        // Метод для добавления задачи в очередь
        public void Enqueue(Action task)
        {
            tasks.Add(task);

             // Enqueue позволяет добавлять задачи в очередь tasks для выполнения рабочими потоками    
        }

        // Деструктор: останавливает все потоки
        ~ThreadPool()
        {
            stop = true; // Устанавливаем флаг stop, чтобы остановить все потоки

             // CompleteAdding() сигнализирует, что больше задач в очередь добавляться не будет
             // Это позволяет потокам завершить свою работу, когда очередь станет пустой
            tasks.CompleteAdding();

            foreach (var worker in workers)
            {
                worker.Join(); // Ожидаем завершения работы каждого потока
            }

             // Join() блокирует текущий поток до завершения работы указанного потока
        }
    }
}